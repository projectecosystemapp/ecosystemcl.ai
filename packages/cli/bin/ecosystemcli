#!/usr/bin/env node

require('dotenv').config();

const { program } = require('commander');
const { AuditPipeline } = require('../src/pipeline');
const AgentDispatcher = require('../src/agentDispatcher');
const EcosystemAuth = require('../src/auth');
const chalk = require('chalk');
const ora = require('ora');
const inquirer = require('inquirer');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const axios = require('axios');
const { EventSource } = require('eventsource');

const auth = new EcosystemAuth();

program
  .name('ecosystemcli')
  .description('Autonomous multi-agent development orchestrator')
  .version('1.0.0');

/**
 * Login command - authenticate with ECOSYSTEMCL.AI platform
 */
program
  .command('login')
  .description('Authenticate with the ECOSYSTEMCL.AI platform')
  .action(async () => {
    try {
      await auth.login();
    } catch (error) {
      console.error(chalk.red('Authentication failed:'), error.message);
      process.exit(1);
    }
  });

/**
 * Logout command
 */
program
  .command('logout')
  .description('Log out from the ECOSYSTEMCL.AI platform')
  .action(async () => {
    try {
      await auth.logout();
    } catch (error) {
      console.error(chalk.red('Logout failed:'), error.message);
      process.exit(1);
    }
  });

/**
 * Status command - show authentication status
 */
program
  .command('status')
  .description('Show authentication and connection status')
  .action(async () => {
    try {
      await auth.status();
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

/**
 * Connect command - connect external services
 */
program
  .command('connect <service>')
  .description('Connect an external service (claude, openai, github, google, aws)')
  .action(async (service) => {
    try {
      await auth.connectService(service);
    } catch (error) {
      console.error(chalk.red(`Failed to connect ${service}:`), error.message);
      process.exit(1);
    }
  });

/**
 * Plan command - submit a high-level goal to MCP and stream progress
 */
program
  .command('plan [goal]')
  .description('Submit a goal for MCP planning and execution (optionally from a prompt file)')
  .option('--prompt-file <path>', 'Path to a prompt file (Markdown)')
  .option('--workspace <id>', 'Workspace ID for context')
  .option('--no-stream', 'Do not stream; just submit and exit')
  .option('--detach', 'Alias for --no-stream')
  .action(async (goal, options) => {
    try {
      const apiUrl = process.env.FORGE_API_URL || 'https://forge.app';

      // Determine goal text
      let finalGoal = goal || '';
      if (options.promptFile) {
        const p = path.resolve(process.cwd(), options.promptFile);
        finalGoal = await fs.readFile(p, 'utf8');
      }
      if (!finalGoal) {
        console.log(chalk.red('Error: You must provide a goal or --prompt-file'));
        process.exit(1);
      }

      // Ensure auth
      const token = await auth.getAccessToken();
      if (!token) {
        console.log(chalk.yellow('‚ö†Ô∏è  Not authenticated. Run "ecosystemcli login" first.'));
        process.exit(1);
      }

      console.log(chalk.bold.cyan('\nüß≠ Submitting plan to MCP...'));
      const res = await axios.post(
        `${apiUrl}/api/forge/execute`,
        {
          goal: finalGoal,
          workspaceId: options.workspace || null,
          executionMode: 'mcp'
        },
        {
          headers: { Authorization: `Bearer ${token}` }
        }
      );

      const data = res.data || {};
      if (!data.success) {
        console.log(chalk.red('‚ùå Plan submission failed'));
        console.log(chalk.gray(JSON.stringify(data, null, 2)));
        process.exit(1);
      }

      const plan = data.plan || {};
      console.log(chalk.green(`‚úÖ Plan created: ${plan.id}`));
      if (options.detach === true || options.stream === false) {
        console.log(chalk.gray('Detached. Use the Web UI to monitor execution.'));
        return;
      }

      const streaming = data.streaming || data.websocketUrl || data.websocketURL || null;
      let streamPath = null;
      if (streaming && typeof streaming === 'object' && streaming.url) {
        streamPath = streaming.url;
      } else if (typeof streaming === 'string') {
        streamPath = streaming;
      }

      if (!streamPath) {
        console.log(chalk.yellow('‚ÑπÔ∏è  No stream URL returned. Plan queued.'));
        return;
      }

      console.log(chalk.gray(`Connecting to stream: ${apiUrl}${streamPath}`));
      const es = new EventSource(`${apiUrl}${streamPath}`, {
        headers: { Authorization: `Bearer ${token}` }
      });

      const onSigint = async () => {
        console.log('\n');
        console.log(chalk.yellow('Cancelling plan (Ctrl+C)...'));
        es.close();
        try {
          await axios.post(`${apiUrl}/api/forge/cancel`, { planId: plan.id }, {
            headers: { Authorization: `Bearer ${token}` }
          });
          console.log(chalk.green('‚úÖ Cancel requested'));
        } catch (e) {
          console.log(chalk.gray('Cancel endpoint not available yet.'));
        } finally {
          process.exit(130);
        }
      };
      process.on('SIGINT', onSigint);

      es.onmessage = (event) => {
        try {
          const payload = JSON.parse(event.data);
          if (payload.type === 'LOG_BLOCK') {
            console.log(chalk.gray('‚îÄ'.repeat(80)));
            console.log(chalk.cyan.bold(`[${payload.agentName || 'Agent'}] LOG BLOCK`));
            const b = payload.block || {};
            if (b.thinking) console.log(chalk.yellow('Thinking:'), b.thinking);
            if (b.reasoning) console.log(chalk.magenta('Reasoning:'), b.reasoning);
            if (b.reference) console.log(chalk.blue('Reference:'), b.reference);
            if (b.action) console.log(chalk.green('Action:'), b.action);
            if (b.result) console.log(chalk.white('Result:'), b.result);
          } else if (payload.type === 'log') {
            console.log(payload.message);
          } else if (payload.type === 'status') {
            console.log(chalk.gray(`Status: ${payload.status}`));
            if (payload.status === 'completed' || payload.status === 'failed' || payload.status === 'cancelled') {
              es.close();
              process.removeListener('SIGINT', onSigint);
            }
          }
        } catch (e) {
          // Ignore parse errors
        }
      };

      es.onerror = (err) => {
        console.error(chalk.red('Stream error'), err.message || err);
      };

    } catch (error) {
      if (axios.isAxiosError(error) && error.response?.status === 401) {
        // Try token refresh via CLI helper
        const creds = await auth.loadCredentials();
        if (creds?.refresh_token) {
          const refreshed = await auth.refreshToken(creds.refresh_token);
          if (refreshed) {
            console.log(chalk.gray('Retried after token refresh; please re-run your command.'));
            process.exit(1);
          }
        }
      }
      console.error(chalk.red('Plan command failed:'), error.message);
      process.exit(1);
    }
  });

/**
 * Init command - initialize FORGE workspace with authentication
 */
program
  .command('init')
  .description('Initialize an ECOSYSTEMCL.AI workspace in the current directory')
  .option('-f, --force', 'Force initialization even if workspace exists')
  .action(async (options) => {
    console.log(chalk.blue.bold('\nüöÄ ECOSYSTEMCL.AI Workspace Initialization\n'));
    
    // Check authentication first
    const isAuth = await auth.isAuthenticated();
      if (!isAuth) {
        console.log(chalk.yellow('‚ö†Ô∏è  You need to authenticate first\n'));
        const { doLogin } = await inquirer.prompt([{
          type: 'confirm',
          name: 'doLogin',
          message: 'Would you like to login now?',
          default: true
        }]);
        
        if (doLogin) {
          await auth.login();
        } else {
          console.log(chalk.gray('Run "ecosystemcli login" when ready'));
          process.exit(0);
        }
      }    // Check for existing workspace
    const workspaceDir = '.forge_workspace';
    try {
      await fs.access(workspaceDir);
      if (!options.force) {
        const { overwrite } = await inquirer.prompt([{
          type: 'confirm',
          name: 'overwrite',
          message: 'Workspace already exists. Reinitialize?',
          default: false
        }]);
        
        if (!overwrite) {
          console.log(chalk.gray('Initialization cancelled'));
          process.exit(0);
        }
      }
    } catch {}
    
    // Get connected services
    const creds = await auth.loadCredentials();
    const connectedServices = creds?.connected_services || {};
    
    if (Object.keys(connectedServices).length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  No services connected yet\n'));
        console.log(chalk.gray('Recommended services:'));
        console.log(chalk.gray('  ‚Ä¢ Claude (ecosystemcli connect claude) - For planning and review'));
        console.log(chalk.gray('  ‚Ä¢ OpenAI (ecosystemcli connect openai) - For code generation'));
        console.log(chalk.gray('  ‚Ä¢ GitHub (ecosystemcli connect github) - For repository access\n'));      const { connectNow } = await inquirer.prompt([{
        type: 'confirm',
        name: 'connectNow',
        message: 'Would you like to connect services now?',
        default: true
      }]);
      
      if (connectNow) {
        const { servicesToConnect } = await inquirer.prompt([{
          type: 'checkbox',
          name: 'servicesToConnect',
          message: 'Select services to connect:',
          choices: [
            { name: 'Claude', value: 'claude', checked: true },
            { name: 'OpenAI', value: 'openai', checked: true },
            { name: 'GitHub', value: 'github', checked: true },
            { name: 'Google Cloud', value: 'google' },
            { name: 'AWS', value: 'aws' }
          ]
        }]);
        
        for (const service of servicesToConnect) {
          console.log(chalk.blue(`\nConnecting ${service}...`));
          await auth.connectService(service);
        }
      }
    }
    
    // Run the initialization script
    const spinner = ora('Initializing workspace...').start();
    
    try {
      const scriptPath = path.join(__dirname, '..', '..', '..', 'scripts', 'forge_init.sh');
      const { stdout, stderr } = await execAsync(`bash "${scriptPath}"`);
      
      if (stderr && !stderr.includes('already exists')) {
        console.warn(chalk.yellow('\nWarnings:'), stderr);
      }
      
      spinner.succeed('Workspace initialized!');
      
      // Update agent configs with connected services
      if (Object.keys(connectedServices).length > 0) {
        console.log(chalk.blue('\nüìù Configuring agents with connected services...'));
        
        const agentsDir = path.join(workspaceDir, 'agents');
        const agentFiles = await fs.readdir(agentsDir);
        
        for (const file of agentFiles) {
          if (!file.endsWith('.yml')) continue;
          
          const agentPath = path.join(agentsDir, file);
          let config = await fs.readFile(agentPath, 'utf8');
          
          // Update model IDs based on connected services
          if (connectedServices.claude && config.includes('claude-')) {
            config = config.replace(/model_id: ".*"/, 'model_id: "claude-3-opus-20240229" # Via ECOSYSTEMCL.AI platform');
          } else if (connectedServices.openai && config.includes('gpt-')) {
            config = config.replace(/model_id: ".*"/, 'model_id: "gpt-4o" # Via ECOSYSTEMCL.AI platform');
          }
          
          // Add auth method indicator
          if (!config.includes('auth_method')) {
            config += '\nauth_method: "forge_platform" # Credentials managed securely by ECOSYSTEMCL.AI\n';
          }
          
          await fs.writeFile(agentPath, config);
        }
        
        console.log(chalk.green('‚úÖ Agents configured with platform authentication'));
      }
      
      console.log(chalk.green.bold('\n‚úÖ Workspace ready!'));
        console.log(chalk.gray('\nNext steps:'));
        console.log(chalk.gray('  1. Review agent configurations in .forge_workspace/agents/'));
        console.log(chalk.gray('  2. Customize system prompts in .forge_workspace/agents/prompts/'));
        console.log(chalk.gray('  3. Run your first audit: ecosystemcli audit --security-scan'));    } catch (error) {
      spinner.fail('Initialization failed');
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

/**
 * Audit command - comprehensive codebase analysis and fixes
 */
program
  .command('audit')
  .description('Run comprehensive codebase audit with parallel agents')
  .option('--fix-lint', 'Automatically fix linting issues')
  .option('--analyze-logic', 'Deep logic analysis for bugs')
  .option('--security-scan', 'Security vulnerability scanning')
  .option('--migration-check', 'Check for Lambda URL migrations needed')
  .option('--parallelism <n>', 'Number of parallel agents', '4')
  .option('--mode <mode>', 'Execution mode: interactive or autonomous', 'interactive')
  .action(async (options) => {
    console.log(chalk.bold.cyan('\nüî• ECOSYSTEMCL.AI AUDIT SYSTEM ACTIVATED\n'));
    
    // Check for previous sessions first
    const sessionDir = '.forge/sessions';
    let resumeSession = false;
    let sessionToResume = null;
    
    try {
      const sessions = await fs.readdir(sessionDir);
      const sessionFiles = sessions.filter(f => f.endsWith('.json'));
      
      if (sessionFiles.length > 0 && options.mode === 'interactive') {
        // Load and analyze recent sessions
        const recentSessions = [];
        
        for (const file of sessionFiles.slice(-5)) { // Last 5 sessions
          const sessionPath = path.join(sessionDir, file);
          const data = JSON.parse(await fs.readFile(sessionPath, 'utf8'));
          const age = Date.now() - new Date(data.timestamp).getTime();
          
          if (age < 86400000) { // Less than 24 hours old
            recentSessions.push({
              name: file,
              sessionId: data.sessionId,
              timestamp: data.timestamp,
              completedTasks: data.completedTasks.length,
              totalTasks: data.tasks.length,
              age: Math.floor(age / 60000) // Age in minutes
            });
          }
        }
        
        if (recentSessions.length > 0) {
          console.log(chalk.yellow('\n‚ö†Ô∏è  Previous sessions detected:\n'));
          
          recentSessions.forEach(session => {
            console.log(chalk.gray(`   ${session.sessionId}`));
            console.log(chalk.gray(`      Progress: ${session.completedTasks}/${session.totalTasks} tasks`));
            console.log(chalk.gray(`      Age: ${session.age} minutes ago\n`));
          });
          
          const { action } = await inquirer.prompt([{
            type: 'list',
            name: 'action',
            message: 'What would you like to do?',
            choices: [
              { name: 'üîÑ Continue from most recent checkpoint', value: 'continue' },
              { name: 'üÜï Start fresh (delete previous sessions)', value: 'fresh' },
              { name: 'üìã View session details', value: 'details' },
              { name: '‚ùå Cancel', value: 'cancel' }
            ]
          }]);
          
          if (action === 'continue') {
            resumeSession = true;
            sessionToResume = recentSessions[recentSessions.length - 1];
            console.log(chalk.green(`\n‚úÖ Resuming session: ${sessionToResume.sessionId}`));
          } else if (action === 'fresh') {
            // Clean up old sessions
            for (const file of sessionFiles) {
              await fs.unlink(path.join(sessionDir, file));
            }
            console.log(chalk.yellow('   Cleared previous sessions'));
          } else if (action === 'details') {
            // Show detailed session info
            const { sessionChoice } = await inquirer.prompt([{
              type: 'list',
              name: 'sessionChoice',
              message: 'Select a session to view:',
              choices: recentSessions.map(s => ({
                name: `${s.sessionId} (${s.completedTasks}/${s.totalTasks} tasks)`,
                value: s.name
              }))
            }]);
            
            const sessionData = JSON.parse(await fs.readFile(path.join(sessionDir, sessionChoice), 'utf8'));
            console.log(chalk.cyan('\nüìä Session Details:'));
            console.log(JSON.stringify(sessionData, null, 2));
            
            const { continueChoice } = await inquirer.prompt([{
              type: 'confirm',
              name: 'continueChoice',
              message: 'Resume this session?',
              default: true
            }]);
            
            if (continueChoice) {
              resumeSession = true;
              sessionToResume = recentSessions.find(s => s.name === sessionChoice);
            } else {
              process.exit(0);
            }
          } else {
            console.log(chalk.red('Audit cancelled'));
            process.exit(0);
          }
        }
      }
    } catch (error) {
      // Session directory doesn't exist yet, continue normally
    }
    
    const tasks = [];
    
    // Build task list based on options
    if (options.fixLint) {
      tasks.push(
        { type: 'lint', target: 'app' },
        { type: 'lint', target: 'components' },
        { type: 'lint', target: 'amplify/functions' },
        { type: 'lint', target: 'lib' }
      );
    }
    
    if (options.analyzeLogic) {
      tasks.push(
        { type: 'logic-analysis', target: 'amplify/functions/stripe-webhook' },
        { type: 'logic-analysis', target: 'amplify/functions/booking-processor' },
        { type: 'logic-analysis', target: 'app/api' },
        { type: 'logic-analysis', target: 'lib' }
      );
    }
    
    if (options.securityScan) {
      tasks.push(
        { type: 'security', target: 'amplify/functions' },
        { type: 'security', target: 'app/api' },
        { type: 'security', target: 'amplify/data' }
      );
    }
    
    if (options.migrationCheck) {
      tasks.push(
        { type: 'migration-check', target: 'amplify/functions' },
        { type: 'migration-check', target: 'lib' },
        { type: 'migration-check', target: 'app' }
      );
    }
    
    if (tasks.length === 0) {
      console.log(chalk.yellow('No audit tasks specified. Use --fix-lint, --analyze-logic, --security-scan, or --migration-check'));
      process.exit(1);
    }
    
    const pipeline = new AuditPipeline({
      parallelism: parseInt(options.parallelism),
      mode: options.mode
    });
    
    try {
      const spinner = ora('Initializing audit pipeline...').start();
      const result = await pipeline.execute(tasks);
      spinner.succeed('Audit complete!');
      
      if (result.conflicts.length > 0 && options.mode === 'interactive') {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Conflicts detected. Manual review required.'));
        console.log('Resolve conflicts in branch:', chalk.cyan(result.integrationBranch));
      }
      
      process.exit(result.failed.length > 0 ? 1 : 0);
    } catch (error) {
      console.error(chalk.red(`\n‚ùå Audit failed: ${error.message}`));
      process.exit(1);
    }
  });

/**
 * Task command - execute arbitrary development task
 */
program
  .command('task')
  .argument('<description>', 'Natural language task description')
  .description('Execute a development task using spec-driven workflow')
  .option('--agent <agent>', 'Specific agent to use', 'spec-architect')
  .action(async (description, options) => {
    console.log(chalk.bold.cyan('\nüöÄ ECOSYSTEMCL.AI TASK EXECUTION\n'));
    console.log(chalk.gray('Task:'), description);
    console.log(chalk.gray('Agent:'), options.agent);
    
    const dispatcher = new AgentDispatcher();
    
    try {
      const spinner = ora('Processing task...').start();
      
      // Skip spec-architect for critical-code-reviewer
      let spec = description;
      if (options.agent !== 'spec-architect' && options.agent !== 'critical-code-reviewer') {
        spinner.text = 'Getting specification...';
        const specResult = await dispatcher.dispatch('spec-architect', description);
        spec = specResult.raw;
      }
      
      // Execute with specified agent
      spinner.text = `Dispatching to ${options.agent}...`;
      const result = await dispatcher.dispatch(options.agent, spec);
      
      spinner.succeed('Task completed!');
      
      console.log(chalk.green('\n‚úÖ Result:'));
      console.log(result.raw);
      
      if (result.fileChanges && result.fileChanges.length > 0) {
        console.log(chalk.cyan('\nüìù Files changed:'));
        result.fileChanges.forEach(change => {
          console.log(`   ${change.action}: ${change.file}`);
        });
      }
      
    } catch (error) {
      console.error(chalk.red(`\n‚ùå Task failed: ${error.message}`));
      process.exit(1);
    }
  });

/**
 * Migrate command - specialized Lambda URL migration
 */
program
  .command('migrate <function-name>')
  .description('Migrate a Lambda function from URL to AppSync')
  .action(async (functionName) => {
    console.log(chalk.bold.cyan('\nüîÑ ECOSYSTEMCL.AI MIGRATION SYSTEM\n'));
    console.log(chalk.gray('Migrating:'), functionName);
    
    const dispatcher = new AgentDispatcher();
    
    try {
      const spinner = ora('Analyzing function...').start();
      
      const migrationPrompt = `
        Migrate the Lambda function "${functionName}" from Lambda URL to AppSync pattern:
        1. Update the handler to accept AppSyncResolverEvent
        2. Add the mutation/query to amplify/data/resource.ts
        3. Update lib/amplify-client-wrapper.ts with feature flag
        4. Update all frontend calls to use the wrapper
        5. Create tests for both legacy and new patterns
      `;
      
      const result = await dispatcher.dispatch('legacy-modernization-specialist', migrationPrompt);
      
      spinner.succeed('Migration plan created!');
      
      console.log(chalk.green('\n‚úÖ Migration completed:'));
      console.log(result.raw);
      
    } catch (error) {
      console.error(chalk.red(`\n‚ùå Migration failed: ${error.message}`));
      process.exit(1);
    }
  });

/**
 * Agents command - list available agents
 */
program
  .command('agents')
  .description('List all available specialist agents')
  .action(() => {
    console.log(chalk.bold.cyan('\nü§ñ Available Specialist Agents:\n'));
    
    const agents = [
      { name: 'spec-architect', role: 'Specification and planning', emoji: 'üìã' },
      { name: 'tdd-implementer', role: 'Test-driven development', emoji: 'üß™' },
      { name: 'critical-code-reviewer', role: 'Security and code review', emoji: 'üîç' },
      { name: 'legacy-modernization-specialist', role: 'Lambda URL to AppSync migration', emoji: 'üîÑ' },
      { name: 'devops-build-manager', role: 'Build and deployment', emoji: 'üöÄ' },
      { name: 'ui-architect-typescript', role: 'TypeScript UI development', emoji: 'üé®' },
      { name: 'marketplace-design-expert', role: 'Marketplace UX/UI design', emoji: 'üõçÔ∏è' }
    ];
    
    agents.forEach(agent => {
      console.log(`${agent.emoji}  ${chalk.cyan(agent.name)}`);
      console.log(`   ${chalk.gray(agent.role)}\n`);
    });
  });

/**
 * Sessions command - manage audit sessions
 */
program
  .command('sessions')
  .description('Manage audit sessions and checkpoints')
  .option('-l, --list', 'List all sessions')
  .option('-c, --clean', 'Clean old sessions')
  .option('-d, --details <sessionId>', 'Show session details')
  .option('-r, --resume <sessionId>', 'Resume a specific session')
  .action(async (options) => {
    console.log(chalk.bold.cyan('\nüìä SESSION MANAGER\n'));
    
    const sessionDir = '.forge/sessions';
    
    try {
      await fs.mkdir(sessionDir, { recursive: true });
      const sessions = await fs.readdir(sessionDir);
      const sessionFiles = sessions.filter(f => f.endsWith('.json'));
      
      if (options.list) {
        if (sessionFiles.length === 0) {
          console.log(chalk.yellow('No sessions found'));
          return;
        }
        
        console.log(chalk.cyan('Available sessions:\n'));
        
        for (const file of sessionFiles) {
          const data = JSON.parse(await fs.readFile(path.join(sessionDir, file), 'utf8'));
          const age = Date.now() - new Date(data.timestamp).getTime();
          
          console.log(chalk.white(`üìÅ ${data.sessionId}`));
          console.log(chalk.gray(`   Created: ${new Date(data.timestamp).toLocaleString()}`));
          console.log(chalk.gray(`   Progress: ${data.completedTasks.length}/${data.tasks.length} tasks`));
          console.log(chalk.gray(`   Age: ${Math.floor(age / 3600000)} hours\n`));
        }
        
      } else if (options.clean) {
        const { confirm } = await inquirer.prompt([{
          type: 'confirm',
          name: 'confirm',
          message: `Delete ${sessionFiles.length} session(s)?`,
          default: false
        }]);
        
        if (confirm) {
          for (const file of sessionFiles) {
            await fs.unlink(path.join(sessionDir, file));
          }
          console.log(chalk.green(`‚úÖ Deleted ${sessionFiles.length} sessions`));
        }
        
      } else if (options.details) {
        const sessionFile = sessionFiles.find(f => f.includes(options.details));
        
        if (!sessionFile) {
          console.log(chalk.red(`Session not found: ${options.details}`));
          return;
        }
        
        const data = JSON.parse(await fs.readFile(path.join(sessionDir, sessionFile), 'utf8'));
        
        console.log(chalk.cyan('Session Details:\n'));
        console.log(chalk.white(`ID: ${data.sessionId}`));
        console.log(chalk.white(`Created: ${new Date(data.timestamp).toLocaleString()}`));
        console.log(chalk.white(`Mode: ${data.mode}`));
        console.log(chalk.white(`Parallelism: ${data.parallelism}`));
        console.log(chalk.white(`\nProgress: ${data.completedTasks.length}/${data.tasks.length} tasks`));
        
        if (data.completedTasks.length > 0) {
          console.log(chalk.green('\nCompleted tasks:'));
          data.completedTasks.forEach(task => {
            console.log(chalk.gray(`   ‚úÖ ${task}`));
          });
        }
        
        const pending = data.tasks.filter(t => !data.completedTasks.includes(t.id));
        if (pending.length > 0) {
          console.log(chalk.yellow('\nPending tasks:'));
          pending.forEach(task => {
            console.log(chalk.gray(`   ‚è≥ ${task.id || task.type}`));
          });
        }
        
      } else if (options.resume) {
        const sessionFile = sessionFiles.find(f => f.includes(options.resume));
        
        if (!sessionFile) {
          console.log(chalk.red(`Session not found: ${options.resume}`));
          return;
        }
        
        console.log(chalk.green(`\nResuming session: ${options.resume}`));
        console.log(chalk.gray('Run the original audit command to continue'));
        
      } else {
        // Interactive session management
        if (sessionFiles.length === 0) {
          console.log(chalk.yellow('No sessions found'));
          return;
        }
        
        const { action } = await inquirer.prompt([{
          type: 'list',
          name: 'action',
          message: 'What would you like to do?',
          choices: [
            { name: 'üìã List all sessions', value: 'list' },
            { name: 'üîç View session details', value: 'details' },
            { name: 'üßπ Clean old sessions', value: 'clean' },
            { name: '‚ùå Cancel', value: 'cancel' }
          ]
        }]);
        
        if (action === 'list') {
          program.parse(['', '', 'sessions', '--list']);
        } else if (action === 'details') {
          const { session } = await inquirer.prompt([{
            type: 'list',
            name: 'session',
            message: 'Select a session:',
            choices: sessionFiles.map(f => {
              const name = f.replace('.json', '');
              return { name, value: name };
            })
          }]);
          program.parse(['', '', 'sessions', '--details', session]);
        } else if (action === 'clean') {
          program.parse(['', '', 'sessions', '--clean']);
        }
      }
      
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

// Parse arguments
program.parse(process.argv);

// Show help if no command provided
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
